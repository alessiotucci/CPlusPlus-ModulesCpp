!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/nfs/homes/atucci/Desktop/CPlusPlus-ModulesCpp/cpp09/ex02/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
$(NAME)	Makefile	/^$(NAME): $(OBJ)$/;"	t
%.o	Makefile	/^%.o: %.cpp$/;"	t
BG_CYAN	PmergeMe.hpp	/^# define BG_CYAN /;"	d
BG_GREEN	PmergeMe.hpp	/^# define BG_GREEN /;"	d
BG_RED	PmergeMe.hpp	/^# define BG_RED /;"	d
BG_RESET	PmergeMe.hpp	/^# define BG_RESET /;"	d
BG_YELLOW	PmergeMe.hpp	/^# define BG_YELLOW /;"	d
BLUE	PmergeMe.hpp	/^# define BLUE /;"	d
CXX	Makefile	/^CXX = c++$/;"	m
CYAN	Makefile	/^CYAN := \\033[1;36m$/;"	m
CYAN	PmergeMe.hpp	/^# define CYAN /;"	d
DequePrint	PmergeMe.cpp	/^static void DequePrint(const std::deque<int> &d)$/;"	f	typeref:typename:void	file:
FLAG	Makefile	/^FLAG = -Wall -Wextra -Werror -std=c++98$/;"	m
GRAY	PmergeMe.hpp	/^# define GRAY /;"	d
GREEN	Makefile	/^GREEN := \\033[1;32m$/;"	m
GREEN	PmergeMe.hpp	/^# define GREEN /;"	d
HEADERS	Makefile	/^HEADERS = PmergeMe.hpp \\$/;"	m
NAME	Makefile	/^NAME = PmergeMe$/;"	m
PMERGEME_HPP	PmergeMe.hpp	/^# define PMERGEME_HPP$/;"	d
PURPLE	PmergeMe.hpp	/^# define PURPLE /;"	d
Pmergeme	PmergeMe.cpp	/^Pmergeme::Pmergeme() { }$/;"	f	class:Pmergeme
Pmergeme	PmergeMe.cpp	/^Pmergeme::Pmergeme(const Pmergeme& other)$/;"	f	class:Pmergeme
Pmergeme	PmergeMe.hpp	/^class Pmergeme$/;"	c
RED	Makefile	/^RED := \\033[1;31m$/;"	m
RED	PmergeMe.hpp	/^# define RED /;"	d
RESET	Makefile	/^RESET := \\033[0m$/;"	m
RESET	PmergeMe.hpp	/^# define RESET /;"	d
SOURCE	Makefile	/^SOURCE = PmergeMe.cpp \\$/;"	m
VectorPrint	PmergeMe.cpp	/^static void VectorPrint(const std::vector<int> &v)$/;"	f	typeref:typename:void	file:
YELLOW	Makefile	/^YELLOW := \\033[1;33m$/;"	m
YELLOW	PmergeMe.hpp	/^# define YELLOW /;"	d
_deque	PmergeMe.hpp	/^	std::deque<int> _deque;$/;"	m	class:Pmergeme	typeref:typename:std::deque<int>
_vector	PmergeMe.hpp	/^	std::vector<int> _vector;$/;"	m	class:Pmergeme	typeref:typename:std::vector<int>
all	Makefile	/^all: $(NAME)$/;"	t
buildBaseChainFromWinners	PmergeMe.cpp	/^static std::vector<int> buildBaseChainFromWinners(const std::vector<int> &winners)$/;"	f	typeref:typename:std::vector<int>	file:
buildBaseChainFromWinnersDeque	PmergeMe.cpp	/^static std::deque<int> buildBaseChainFromWinnersDeque(const std::deque<int> &winners)$/;"	f	typeref:typename:std::deque<int>	file:
buildPairsFromDeque	PmergeMe.cpp	/^void Pmergeme::buildPairsFromDeque(const std::deque<int> &elements, std::deque< std::pair<int,in/;"	f	class:Pmergeme	typeref:typename:void
buildPairsFromVector	PmergeMe.cpp	/^void Pmergeme::buildPairsFromVector(const std::vector<int> &elements, std::vector< std::pair<int/;"	f	class:Pmergeme	typeref:typename:void
clean	Makefile	/^clean:$/;"	t
collectWinnersFromPairs	PmergeMe.cpp	/^void Pmergeme::collectWinnersFromPairs(const std::vector< std::pair<int,int> > &pairs, std::vect/;"	f	class:Pmergeme	typeref:typename:void
collectWinnersFromPairsDeque	PmergeMe.cpp	/^void Pmergeme::collectWinnersFromPairsDeque(const std::deque< std::pair<int,int> > &pairs, std::/;"	f	class:Pmergeme	typeref:typename:void
containsDuplicate	PmergeMe.cpp	/^bool Pmergeme::containsDuplicate(const std::vector<int> &vec, int value) const$/;"	f	class:Pmergeme	typeref:typename:bool
fclean	Makefile	/^fclean: clean$/;"	t
fillDeque	PmergeMe.cpp	/^void Pmergeme::fillDeque(const std::vector<int> &values)$/;"	f	class:Pmergeme	typeref:typename:void
fillVector	PmergeMe.cpp	/^void Pmergeme::fillVector(const std::vector<int> &values)$/;"	f	class:Pmergeme	typeref:typename:void
getDeque	PmergeMe.cpp	/^const std::deque<int>&  Pmergeme::getDeque()  const { return _deque; }$/;"	f	class:Pmergeme	typeref:typename:const std::deque<int> &
getVector	PmergeMe.cpp	/^const std::vector<int>& Pmergeme::getVector() const { return _vector; }$/;"	f	class:Pmergeme	typeref:typename:const std::vector<int> &
hidden	Makefile	/^hidden:$/;"	t
insertBeforePartner	PmergeMe.cpp	/^static void insertBeforePartner(std::vector<int> &chain, int loser, int partner)$/;"	f	typeref:typename:void	file:
insertBeforePartnerDeque	PmergeMe.cpp	/^static void insertBeforePartnerDeque(std::deque<int> &chain, int loser, int partner)$/;"	f	typeref:typename:void	file:
insertLeftoverIntoChain	PmergeMe.cpp	/^static void insertLeftoverIntoChain(std::vector<int> &chain, bool hasLeftover, int leftover)$/;"	f	typeref:typename:void	file:
insertLeftoverIntoChainDeque	PmergeMe.cpp	/^static void insertLeftoverIntoChainDeque(std::deque<int> &chain, bool hasLeftover, int leftover)$/;"	f	typeref:typename:void	file:
insertLosersByJacobsthal	PmergeMe.cpp	/^static void insertLosersByJacobsthal(std::vector<int> &chain, const std::vector< std::pair<int,i/;"	f	typeref:typename:void	file:
insertLosersByJacobsthalDeque	PmergeMe.cpp	/^static void insertLosersByJacobsthalDeque(std::deque<int> &chain, const std::deque< std::pair<in/;"	f	typeref:typename:void	file:
isValidNumber	PmergeMe.cpp	/^bool Pmergeme::isValidNumber(const std::string &tok, int &outValue) const$/;"	f	class:Pmergeme	typeref:typename:bool
jacobsthal_indices	PmergeMe.cpp	/^std::vector<std::size_t> jacobsthal_indices(std::size_t limit)$/;"	f	typeref:typename:std::vector<std::size_t>
main	main.cpp	/^int main(int ac, char **av)$/;"	f	typeref:typename:int
makePairsFromDeque	PmergeMe.cpp	/^int Pmergeme::makePairsFromDeque(std::vector< std::pair<int,int> > &outPairs, bool &hasLeftover,/;"	f	class:Pmergeme	typeref:typename:int
makePairsFromVector	PmergeMe.cpp	/^int Pmergeme::makePairsFromVector(std::vector< std::pair<int,int> > &outPairs, bool &hasLeftover/;"	f	class:Pmergeme	typeref:typename:int
operator =	PmergeMe.cpp	/^Pmergeme& Pmergeme::operator=(const Pmergeme& other)$/;"	f	class:Pmergeme	typeref:typename:Pmergeme &
parseArgs	PmergeMe.cpp	/^int Pmergeme::parseArgs(int ac, char **av)$/;"	f	class:Pmergeme	typeref:typename:int
parseInput	PmergeMe.cpp	/^int Pmergeme::parseInput(const std::string &s)$/;"	f	class:Pmergeme	typeref:typename:int
power_of_two	PmergeMe.cpp	/^static std::size_t power_of_two(std::size_t exp)$/;"	f	typeref:typename:std::size_t	file:
printDeque	PmergeMe.cpp	/^void Pmergeme::printDeque() const$/;"	f	class:Pmergeme	typeref:typename:void
printPairs	PmergeMe.cpp	/^void printPairs(const std::vector< std::pair<int, int> > &pairs, size_t index)$/;"	f	typeref:typename:void
printVector	PmergeMe.cpp	/^void Pmergeme::printVector() const$/;"	f	class:Pmergeme	typeref:typename:void
re	Makefile	/^re: fclean all$/;"	t
recursePairs	PmergeMe.cpp	/^void Pmergeme::recursePairs(const std::vector<int> &elements) const$/;"	f	class:Pmergeme	typeref:typename:void
recursePairsDeque	PmergeMe.cpp	/^void Pmergeme::recursePairsDeque(const std::deque<int> &elements) const$/;"	f	class:Pmergeme	typeref:typename:void
recursePairsImpl	PmergeMe.cpp	/^std::vector<int> Pmergeme::recursePairsImpl(const std::vector<int> &elements, int level) const$/;"	f	class:Pmergeme	typeref:typename:std::vector<int>
recursePairsImplDeque	PmergeMe.cpp	/^std::deque<int> Pmergeme::recursePairsImplDeque(const std::deque<int> &elements, int level) cons/;"	f	class:Pmergeme	typeref:typename:std::deque<int>
swapPairsDeque	PmergeMe.cpp	/^void Pmergeme::swapPairsDeque(std::deque< std::pair<int,int> > &pairs, bool hasLeftover, int lef/;"	f	class:Pmergeme	typeref:typename:void
swapPairsVector	PmergeMe.cpp	/^void Pmergeme::swapPairsVector(std::vector< std::pair<int,int> > &pairs, bool hasLeftover, int l/;"	f	class:Pmergeme	typeref:typename:void
validate_and_normalize_input	PmergeMe.cpp	/^static bool validate_and_normalize_input(std::vector<int> &values)$/;"	f	typeref:typename:bool	file:
~Pmergeme	PmergeMe.cpp	/^Pmergeme::~Pmergeme() { }$/;"	f	class:Pmergeme
